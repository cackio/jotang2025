# q9

bar函数运行更快，主要原因是假共享（False Sharing）。虽然add_a／add_b分别只修改data_x.a和data_x.b，但它们是同一个struct data的两个连续成员，极大可能被放在同一个缓存行（通常 64 字节）里。当两个线程同时向同一缓存行内的不同字节写入时，就会在各自核心的缓存间频繁产生缓存行的无效和同步，大幅拖慢写入速度，也就是所说的假共享。

性能测试结果：
```
Sum foo : 1000000000
Sum bar : 1000000000
foo耗时: 1354 ms
bar耗时: 508 ms
```
可以看到foo函数比bar函数差了两倍多。

## 如何优化foo()
消除假共享：给每个变量单独对齐／填充一个缓存行
```c++
struct data {
    alignas(64) int a;
    char pad[64 - sizeof(int)];
    alignas(64) int b;
    char pad2[64 - sizeof(int)];
};
```
这样a、b分别占用不同的缓存行，两个线程的写操作就不会互相打扰。
这时候再测试性能：

```
Sum foo : 1000000000
Sum bar : 1000000000
foo耗时: 261 ms
bar耗时: 509 ms
```
这时foo比bar函数快了两倍多，可见假共享确实是foo函数运行更慢的主要原因。