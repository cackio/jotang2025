# q4 & q5

## q4：为什么分块能提升性能

我认为一个重要原因是能提升数据的局部性，原始代码中，对 image[(i + t) * Y + j] 的访问是沿着列方向（即 i 方向）进行，而内存中是按行连续存储的，这会导致访问内存跨行跳跃，频繁导致cache missing，分块后，k 的变化使得访问 j + k，即当前列块的多个相邻列，这样 image[(i + t) * Y + (j + k)] 更可能落在同一缓存行或相邻缓存行中，提升了cache hit率。

本地测试结果：
```
Average time over 10 runs:
blur_y:      4591.969 ms
blur_y_tile: 960.596 ms
```
可以看到性能提升了非常多

## q5 还有哪些优化常见的优化手段

### 1.SIMD

在分块进行运算时满足向量化条件，可以让编译器进行向量化
```
使用编译命令：gcc -O3 -march=native
再看看汇编代码是否真的向量化了
部分SIMD相关汇编指令：
vpaddd	%ymm10, %ymm9, %ymm9
vpslld	$31, %ymm7, %ymm7
vpaddd	%ymm9, %ymm8, %ymm9
vpmaskmovd	(%rdi,%rax,4), %ymm7, %ymm8
vpslld	$31, %ymm6, %ymm6
leaq	(%r12,%r14), %rax
vpmaskmovd	(%rdi,%rax,4), %ymm6, %ymm10
vcvtsi2sdq	16(%rsp), %xmm0, %xmm0

```
性能测试结果：
```
Average time over 10 runs:
blur_y:      4044.252 ms
blur_y_tile_SIMD: 377.726 ms
```
可以看到现在已经让执行时间降低了10倍以上

### 2.减少循环中的if分支
减少if分支的优化，主要作用在于消除或弱化控制流依赖，让CPU能更好地利用流水线、向量化和并发执行。

```c
void blur_y_tile_SIMD(const int *image, int *image_blur) {
    for (int j = 0; j < Y; j += 16) {
        int tile_h = MIN(16, Y - j);
        for (int i = 0; i < X; i++) {
            for (int k = 0; k < tile_h; k++) {
                int sum = 0;
                for (int t = -BLUR_SIZE; t <= BLUR_SIZE; t++) {
                    int ii = i + t;
                    if (ii >= 0 && ii < X) {
                        sum += image[ii * Y + (j + k)];
                    }
                }
                image_blur[i * Y + (j + k)] = sum / (2 * BLUR_SIZE + 1);
            }
        }
    }
}
```
这段代码中的每次迭代都会有if分支来处理边界条件，但边界之外部分是不需要if判断的，而总的循环次数又非常多，所以if分支严重影响了该函数的性能，可以把边界情况单独拿出来处理。具体代码如下：
```c
void blur_y_tile_SIMD_lessif(const int * image, int * image_blur) {
    const int D = 2 * BLUR_SIZE + 1; // =9

    for (int j = 0; j < Y; j += 16) {
        int tile_h = MIN(16, Y - j);
        //上边界
        for (int i = 0; i < BLUR_SIZE; i++) {
            for (int k = 0; k < tile_h; k++) {
                int sum = 0;
                for (int t = -BLUR_SIZE; t <= BLUR_SIZE; t++) {
                    int ii = i + t;
                    if (ii >= 0 && ii < X) {
                        sum += image[ii * Y + (j + k)];
                    }
                }
                image_blur[i * Y + (j + k)] = sum / D;
            }
        }

        for (int i = BLUR_SIZE; i < X - BLUR_SIZE; i++) {
            for (int k = 0; k < tile_h; k++) {
                int sum = 0;
                for (int t = -BLUR_SIZE; t <= BLUR_SIZE; t++) {
                    sum += image[(i + t) * Y + (j + k)];
                }
                image_blur[i * Y + (j + k)] = sum / D;
            }
        }
        //下边界
        for (int i = X - BLUR_SIZE; i < X; i++) {
            for (int k = 0; k < tile_h; k++) {
                int sum = 0;
                for (int t = -BLUR_SIZE; t <= BLUR_SIZE; t++) {
                    int ii = i + t;
                    if (ii >= 0 && ii < X) {
                        sum += image[ii * Y + (j + k)];
                    }
                }
                image_blur[i * Y + (j + k)] = sum / D;
            }
        }
    }
}
```
性能测试结果：
```
Average time over 10 runs:
blur_y:      4044.252 ms
blur_y_tile_SIMD: 377.726 ms
blur_y_tile_SIMD_lessif: 292.765 ms
```
现在性能又进一步。

### 多线程

多线程通过并行化计算任务，把工作分配到多个CPU核心上，以减少总执行时间，提升计算效率。

代码中我使用的是OpenMP实现多线程，OpenMP是一个支持多平台共享内存多线程编程的 并行编程接口，用于在 C/C++等程序中实现多线程并行化，主要用于多核CPU上加速程序执行。
```c
void blur_y_tile_SIMD_lessif_threads(const int * image, int * image_blur) {
    const int D = 2 * BLUR_SIZE + 1; // =9
    #pragma omp parallel for schedule(dynamic)
    for (int j = 0; j < Y; j += 16) {
        int tile_h = MIN(16, Y - j);

        for (int i = 0; i < BLUR_SIZE; i++) {
            for (int k = 0; k < tile_h; k++) {
                int sum = 0;
                for (int t = -BLUR_SIZE; t <= BLUR_SIZE; t++) {
                    int ii = i + t;
                    if (ii >= 0 && ii < X) {
                        sum += image[ii * Y + (j + k)];
                    }
                }
                image_blur[i * Y + (j + k)] = sum / D;
            }
        }

        for (int i = BLUR_SIZE; i < X - BLUR_SIZE; i++) {
            for (int k = 0; k < tile_h; k++) {
                int sum = 0;
                for (int t = -BLUR_SIZE; t <= BLUR_SIZE; t++) {
                    sum += image[(i + t) * Y + (j + k)];
                }
                image_blur[i * Y + (j + k)] = sum / D;
            }
        }
        for (int i = X - BLUR_SIZE; i < X; i++) {
            for (int k = 0; k < tile_h; k++) {
                int sum = 0;
                for (int t = -BLUR_SIZE; t <= BLUR_SIZE; t++) {
                    int ii = i + t;
                    if (ii >= 0 && ii < X) {
                        sum += image[ii * Y + (j + k)];
                    }
                }
                image_blur[i * Y + (j + k)] = sum / D;
            }
        }
    }
}
```
代码中每个线程处理一个或多个完整的j列表，每个线程并行执行代码。

性能测试结果：
```
Average time over 10 runs:
blur_y:      4044.252 ms
blur_y_tile_SIMD_lessif: 292.765 ms
blur_y_tile_SIMD_lessif_threads: 75.306 ms
```
可以看到使用多线程后性能又有了很大的提升，相比于naive实现性能提升了50倍以上。

总的性能数据对比
```
Average time over 10 runs:
blur_y:      4044.252 ms
blur_y_tile_SIMD: 377.726 ms
blur_y_tile_SIMD_threads: 200.167 ms
blur_y_tile_SIMD_lessif: 292.765 ms
blur_y_tile_SIMD_lessif_threads: 75.306 ms
```

源文件是同文件夹下loop_tiling.c文件。